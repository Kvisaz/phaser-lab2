# Игровые компоненты на Phaser/TypeScript

Напиши мне код игрового компонента для мини-игры [ ....если не указано, спроси тему и условия мини-игры... ]

## Код
У меня уже есть базовый каркас кода на Phaser, который создает игру и сцену в ней, в которой будет запущен компонент, так что сосредоточься на самой задаче.

Пиши код для Phaser 3.80 на TypeScript, разбивая его на компоненты, как указано в примере
```typescript
/** Комментарии здесь относятся только к стилю написания компонентов,
 * не к самому компоненту
 **/

/** Компонент всегда принимает аргументы объектом в конструктор - пропсы **/
interface IProps {
  // общие для всех 
  scene: Phaser.Scene; 
  isLogging?: boolean; 
  // далее уникальные для компонента
  text: string;
}

/** Компонент не обязательно происходит от контейнера, но всегда от игрового объекта **/
export class TestButton extends Phaser.GameObjects.Container {
  constructor(private props: IProps) {
    super(props.scene);
    
    /** обрати внимание на доступ к полям в пропсах, это сильно экономит пространство, так и пиши **/
    const { scene, text } = this.props;
    const textObject = scene.add.text(0, 0, text, { fontSize: "32px", color: "#dedede" });

    this.add([textObject]);
    
    /** в конце конструктора всегда добавляем объект к сцене **/
    scene.add.existing(this as Phaser.GameObjects.Container);
  }
}
```

Если компонент создает объекты или подписки, которые не удаляются автоматически при его destroy - переопредели его метод destroy и после super.destroy() - произведи уничтожение или отписки.

## События - Взаимодействие между компонентами и другими частями игры
Для гибкости и модульности используй подписку и отправку типизированных эвентов через scene.events
EventName должен иметь префикс, отражающий имя компонента.

Все EventNames должны быть сгруппированны в enum с названием типа ComponentNameEvents. Этот enum будет всегда лежать рядом в той же папке, что и компонент, в файле с названием events.ts

Реализуй общий метод для такой подписки, который возвращает сразу функции отписки - тогда ее можно будет положить в массив unSubs и вызвать в destroy компонента

## Графика
Код может использовать графические ассеты, если необходимо - просто используй читабельные выдуманные переменные для  textureKey, frameName/frameIndex в создании спрайтов. Я позабочусь о том, чтобы они были загружены.

Сгруппируй эти переменные в объект типа ComponentNameAssetImages со структурой типа
```typescript
export const MineSweeperAssetImages = {
  cell: {
    textureName: string,
    frameName: string|number|undefined,
  },
  mine: {
    textureName: string,
    frameName: string|number|undefined,
  }
};
```

Этот const будет всегда лежать рядом в той же папке, что и компонент, в файле с названием assets.ts

## Утилиты и функции
По возможности старайся выносить код в утилитные функции, особенно если возможно создать чистую функцию, для которой можно написать тесты на ts-jest. Эти функции компоненты должны лежать рядом в той же папке, что и компонент, в файле с названием utils.ts.

При написании такой функции предложи всегда 3-4 теста на ts-jest, они будут лежать в той же папке в файле utils.test.ts

## Документация и комментарии
Не используй комментарии, вместо этого используй разбиение на методы и переменные с читабельными названиями. 

## Управление зависимостями
Старайся не использовать никаких новых библиотек и зависимостей.

## Отладка и логирование
если в пропсах указан флаг isLogging?: true - выведи в консоли в конструкторе полученные пропсы.

## Асинхронные операции, таймауты
По возможности используй таймауты и прочии операции со временем через сцену Phaser.

Если асинхронных операций много в одном месте - оформи их как async-await
